(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{402:function(a,e,t){"use strict";t.r(e);var n=t(26),s=Object(n.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"node新手课（5）callback-promise和async-await"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node新手课（5）callback-promise和async-await"}},[a._v("#")]),a._v(" node新手课（5）callback-promise和async-await")]),a._v(" "),t("h2",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),t("p",[a._v("上节课我们讲解了 nodejs 处理 http 请求，今天我们讲下 callback,promise 和 async,await")]),a._v(" "),t("h3",{attrs:{id:"callback"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#callback"}},[a._v("#")]),a._v(" callback")]),a._v(" "),t("p",[a._v("js 代码处理逻辑都是异步，会造成 callback 层层嵌套。简称：回调地狱，非常不好维护，我们举例说明下\n我们在 sir-node 中新建个目录 callback-test, 里面新建个 callback.js")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("$ mkdir callback-test && cd callback-test/\n$ touch callback.js\n")])])]),t("p",[a._v("callback.js")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const fs = require('fs')\nconst path  = require('path')\n//callback 方式获取文件内容\nfunction getFile(fileName,callback){\n    const fullName = path.resolve(__dirname,\"\",fileName)\n    fs.readFile(fullName,(err,data)=>{\n        if(err){\n            console.error(err)\n            return\n        }\n        callback(JSON.parse(data.toString()))\n    })\n}\n// 测试\ngetFile('a.json',aData=>{\n    console.log('aData',aData)\n    getFile(aData.next,bData=>{\n        console.log('bData',bData)\n        getFile(bData.next,cData=>{\n            console.log('cData',cData)\n        })\n    })\n})\n")])])]),t("p",[a._v("再新建 3 个文件 a.json,b.json,c.json，内容如下")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('a.json\n\n{"next":"b.json"}\n\nb.json\n\n{"next":"c.json"}\n\nc.json\n\n{"next":"test"}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("$ node callback.js\naData { next: 'b.json' }\nbData { next: 'c.json' }\ncData { next: 'test' }\n\n")])])]),t("p",[a._v("由此可见，callback 层层嵌套。当然现在只有 3 层，实际项目中可能会有很多层，可想而知维护的难度，接下来就是解决方案。")]),a._v(" "),t("h3",{attrs:{id:"promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[a._v("#")]),a._v(" promise")]),a._v(" "),t("p",[a._v("新建个 promise.js 文件，代码如下")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const fs = require('fs')\nconst path  = require('path')\n//promise 方式获取文件内容\nfunction getFile(fileName){\n    const promise = new Promise((resolve,reject)=>{\n        const fullName = path.resolve(__dirname,\"\",fileName)\n        fs.readFile(fullName,(err,data)=>{\n            if(err){\n                reject(err)\n                return\n            }\n            resolve(JSON.parse(data.toString()))\n        })\n    })\n    return promise\n}\n// 测试\ngetFile('a.json').then(aData=>{\n    console.log('aData',aData)\n    return getFile(aData.next)\n}).then(bData=>{\n    console.log('bData',bData)\n    return getFile(bData.next)\n}).then(cData=>{\n    console.log('cData',cData)\n})\n")])])]),t("p",[a._v("表面看上去代码略微繁琐，但是使用起来很简洁，promise 把 callback 层层嵌套的方式变成了很多个 then 平铺，当然 promise 无法解决把异步代码写成同步的风格，我们来讲下异步写法的终极解决方案，async 和 await")]),a._v(" "),t("h3",{attrs:{id:"async-和-await"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async-和-await"}},[a._v("#")]),a._v(" async 和 await")]),a._v(" "),t("p",[a._v("新建个 async.js 文件，代码如下")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const fs = require('fs')\nconst path  = require('path')\n//promise 方式获取文件内容\nfunction getFile(fileName){\n    const promise = new Promise((resolve,reject)=>{\n        const fullName = path.resolve(__dirname,\"\",fileName)\n        fs.readFile(fullName,(err,data)=>{\n            if(err){\n                reject(err)\n                return\n            }\n            resolve(JSON.parse(data.toString()))\n        })\n    })\n    return promise\n}\n// 测试\nasync function getFileContent(){\n    aData = await getFile('a.json')\n    console.log('aData',aData)\n    bData = await getFile(aData.next)\n    console.log('bData',bData)\n    cData = await getFile(bData.next)\n    console.log('cData',cData)\n}\ngetFileContent()\n")])])]),t("p",[a._v("async 和 await 也是基于 promise 的，代码写法和同步一样了。")]),a._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),t("p",[a._v("今天我们讲了 callback,promise 和 async,await。你掌握了吗？在项目中我们使用的 koa2 框架完全支持 async 和 await。\n有问题欢迎到群里和志同道合的小伙伴一起交流。\n下节课我们介绍项目功能和技术架构，继续加油吧，Let's go！")])])}),[],!1,null,null,null);e.default=s.exports}}]);